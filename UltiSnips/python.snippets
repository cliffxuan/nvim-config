snippet ip "Set iPDB breakpoint" b
import ipdb; ipdb.set_trace()
endsnippet

snippet sb "Shebang header for python scripts" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-
$0
endsnippet

snippet cdec "cdec copyright" b
# (C) Copyright Connected Digital Economy Catapult Limited 2014
# All rights reserved
endsnippet

snippet lg "basic logging" b
format = '%(asctime)s - %(levelname)s - %(message)s'
logging.basicConfig(
    filename=logfile,
    level=logging.DEBUG,
    format=format)
endsnippet

snippet lg "logging to stream" b
format = '%(asctime)s - %(levelname)s - %(message)s'
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter(format))
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.addHandler(ch)
endsnippet

snippet lg "logging to stream and file" b
format = '%(asctime)s - %(levelname)s - %(message)s'
ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter(format))
fh = logging.FileHandler('spam.log')
fh.setFormatter(logging.Formatter(format))
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.addHandler(ch)
logger.addHandler(fh)
endsnippet

snippet lg "logging to stream and file (dictConfig)" b
def get_logger():
    LOGGING = {
        'version': 1,
        'disable_existing_loggers': True,
        'formatters': {
            'simple': {'format': '%(asctime)s - %(levelname)s - %(message)s'}
        },
        'handlers': {
            'console': {
                'level': 'DEBUG',
                'class': 'logging.StreamHandler',
                'formatter': 'simple'
            },
            'file': {
                'level': 'DEBUG',
                'class': 'logging.FileHandler',
                'filename': 'output.log',
                'formatter': 'simple'
            },
        },
        'loggers': {
            __name__: {
                'handlers': ['console', 'file'],
                'level': 'DEBUG'
            }
        }
    }
    logging.config.dictConfig(LOGGING)
    return logging.getLogger(__name__)

logger = get_logger()
endsnippet

snippet ap "argparse" b
    parser = argparse.ArgumentParser(
        description='describe me')
    parser.add_argument(
        '--foo', dest='foo', help='foo')
    parser.add_argument(
        '--bar', dest='bar',
        required=True, help='bar')
    parser.add_argument(
        'eggs', nargs='+', help='one or multiple eggs')
    args = parser.parse_args()
endsnippet

snippet ko "kickoff a python script" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
"""


def main():
    pass


if __name__ == '__main__':
    main()
endsnippet

snippet sac "sqlalchemy connection" !b
import sqlalchemy as sa
from sqlalchemy.orm import sessionmaker


def get_session():
    URI = 'mysql://root@localhost/db'
    sess = sessionmaker(
        bind=sa.create_engine(URI))()
    return sess

endsnippet

snippet cod "encoding for python scripts" b
# -*- coding: utf-8 -*-
$0
endsnippet

snippet conn "sqlalchemy connection" b
import sqlalchemy as sa
conn = sa.create_engine('mysql://user:password@localhost/db').connect()
endsnippet

snippet mindjango "sqlalchemy connection" b
# -*- coding: utf-8 -*-
"""
minimal django app. to run it:
python app.py runserver
"""

import sys

from django.conf import settings
from django.conf.urls import patterns
from django.http import HttpResponse
from django.core.management import execute_from_command_line

settings.configure(
    DEBUG=True,
    SECRET_KEY='placerandomsecretkeyhere',
    ROOT_URLCONF=sys.modules[__name__],
)


def index(request):
    return HttpResponse('Powered by Django')

urlpatterns = patterns('', (r'^$', index),)

if __name__ == "__main__":
    execute_from_command_line(sys.argv)
endsnippet


snippet multithreading "multi threading" b
import threading


def wait_to_run(func, event, sec, *arg, **kw):
    event.wait(sec)
    func(*arg)


def multi_threading(target, concurrency, *args):
    events = [threading.Event() for i in xrange(concurrency)]
    threads = [threading.Thread(target=wait_to_run,
                                args=(target, evt, 2) + args)
               for evt in events]
    for t in threads:
        t.start()
    for e in events:
        e.set()
    for t in threads:
        t.join()
endsnippet


snippet forkthreading "fork and multithreading" b
import os


def wait_to_run(func, event, sec, *arg, **kw):
    event.wait(sec)
    func(*arg)


def multi_threading(target, concurrency, *args):
    events = [threading.Event() for i in xrange(concurrency)]
    threads = [threading.Thread(target=wait_to_run,
                                args=(target, evt, 2) + args)
               for evt in events]
    for t in threads:
        t.start()
    for e in events:
        e.set()
    for t in threads:
        t.join()


def fork_and_multi_threading(target, concurrency, *args):
    pid = os.fork()
    if pid == 0:
        multi_threading(target, concurrency, *args)
        os._exit(0)
    return pid
endsnippet
